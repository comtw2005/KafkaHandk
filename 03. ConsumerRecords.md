在 Kafka 中，消費者組（Consumer Group）是一個用於協調多個消費者的概念，以便從一個或多個主題中消費消息。
如果您想使用 Kafka 的預設消費者組，只需設置 Kafka 消費者的 GROUP_ID_CONFIG 為空字串即可。這將使用 Kafka 的預設消費者組。

* GROUP_ID_CONFIG 為空字串即可 這句話有待驗證, 因為也發生過使用空字串而沒有任何輸出的情況

以下是一個使用預設消費者組的 Java 程式碼範例，用於從主題中讀取消息：

```
public class KafkaDefaultConsumerGroupExample {

    public static void main(String[] args) throws InterruptedException {
        // Kafka 伺服器位置
        String bootstrapServers = "172.20.10.6:9093";
        // Kafka 主題名稱
        String topicName = "test2";

        // 消費者設定
        Properties consumerProps = new Properties();
        consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, "test-consumer-group"); // 使用預設消費者組
        consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());

        KafkaConsumer<String, String> consumer = new KafkaConsumer<>(consumerProps);

        // 訂閱主題
        consumer.subscribe(Collections.singletonList(topicName));

//        // 接收和處理訊息
        while (true) {
           ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));

            // 顯示 offset 對應的內容
            for (ConsumerRecord<String, String> record : records) {
               System.out.printf("offset = %d, key = %s, value = %s, partition = %s \n", record.offset(), record.key(), record.value(), record.partition());
               try {
                   Thread.sleep(100);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }

            // 顯示 offset 開始與結束
            for (TopicPartition partition : consumer.assignment()) {
               consumer.seekToEnd(Collections.singleton(partition));
               long endOffset = consumer.position(partition);

               consumer.seekToBeginning(Collections.singleton(partition));
               long beginningOffset = consumer.position(partition);

               System.out.println("Partition " + partition.partition() + "  Beginning Offset: " + beginningOffset + "  End Offset: " + endOffset);
           }
            
            Thread.sleep(5000);
        }
    }
}
```

下圖範例同時展示出,  log.retention 如果超過時間的動態變動
![圖片](https://github.com/comtw2005/KafkaHandle/assets/46416652/17500889-09ce-4b55-a3c8-0f83eb78fddb)

